{"pages":[],"posts":[{"title":"关于XHR对象一些理解","text":"概述 ajax是asynchronous javascript and XML的简写，中文翻译是异步的javascript和XML，这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。虽然名字中包含XML，但ajax通信与数据格式无关。 ajax包括几个步骤： 1：创建ajax请求，2：发出http请求3：收到服务器传回的消息4：更新网页数据、 概括起来，就是一句话，ajax通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。 创建 ajax技术的核心是XMLHttpRequest对象(简称XHR)，这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。XHR为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步方式从服务器取得更多信息，意味着用户单击后，可以不必刷新页面也能取得新数据 IE5是第一款引入XHR对象的浏览器。在IE5中，XHR对象是通过MSXML库中的一个ActiveX对象实现的，而IE7+及其他标准浏览器都支持原生的XHR对象 创建一个XHR对象，也叫实例化一个XHR对象，因为XMLHTTPRequest()是一个构造函数。下面是创建XHR对象的兼容写法 123456var xhr;if(window.XMLHttpRequest){ xhr = new XMLHttpRequest();}else{ xhr = new ActiveXObject('Microsoft.XMLHTTP');} [注意]如果要建立N个不同的请求，就要使用N个不同的XHR对象。当然可以重用已存在的XHR对象，但这会终止之前通过该对象挂起的任何请求。 发动请求 open(); 在使用xrh的时候第一个调用的是open方法，如下，该方法接受3个参数， 1xrh.open('GET','example.php',false); open()方法的第一个参数用于指定发送请求的方式，这个字符串，不区分大小写，但通常使用大写字母。”GET”和”POST”是得到广泛支持的. ‘GET’用于常规请求，它适用于URL完全指定的资源。当请求对服务器没有任何副作用是可缓存的情况下， ‘POST’方法常用与HTML表单，他在请求主题中额外包含数据且这些数据常存在服务器上的数据库中。相同的URL的重复POST请求从服务器的得到的相应可能不同 除了”GET”和”POST”之外，参数还可以是”HEAD”、”OPTIONS”、”PUT”。而由于安全风险的原因，”CONNECT”、”TRACE”、”TRACK”被禁止使用. 2. open()的第二个参数是URL，该URL对于执行代码的当前页面，且只能想同一域中使用相同协议和端口的URL发送请求。 3.open()的第三个参数是表示是否异步发送请求的值，如果不填写。默认身高true,表示异步发送， 4.如果请求一个手密码保护的URL用于认证的用户和密码作为第4和第5个参数传递给open()方法。 send() send()方法接受一个参数，即作为请求主题发送的数据。调用send()方法后，请求被分配到服务器。 如果是GET方法，send()方法无参数，或参数为null；如果是POST方法，send()方法的参数是要发送的的数据。 12xhr.open(&quot;GET&quot;,&quot;xxx.php&quot;,true)xhr.send(null); 接受响应 一个完整的http响应是有状态吗，响应头集合，和响应主题组成。在收到响应的消息后，这些都是可以通过xhr对象的属性个方法所使用，主要有一下4个属性 12345responseText;作为相应主题返回的文本，（文本形式）responseXML;如果响应的内容是‘text/xml’或者是哦application/xml;属性中将会保存，响应数据的xml形式。DOM文档形式。status: http的状态码（数字形式）statusText;http状态说明，（文本形式） 收到响应后，第一步是检查status,以确定响应已经成功的返回，一般来说。http状态码200作为成功的标志。此时，responseText属性的内容也已经准备就绪，而且在内容正确的情况下,responseText的内容也可以访问了，此外状态码304表示资源并没有被修改，可以直接使用浏览器中的缓存。 无论响应内容是什么类型。都会被保存在responseText中，而对于非XML数据而言，responseText的值则为null; 1 除了&quot;GET&quot;和&quot;POST&quot;之外，参数还可以是&quot;HEAD&quot;、&quot;OPTIONS&quot;、&quot;PUT&quot;。而由于安全风险的原因，&quot;CONNECT&quot;、&quot;TRACE&quot;、&quot;TRACK&quot;被禁止使用 同步 如果接受的是同步响应，在在open()方法的第三个参数设置为false，那么send()方法将阻塞，直到请求完成，一旦send()返回，仅需检查XHR对象的responseText属性和status即可。 同步请求是吸引人的，但应该避免使用它们。客户端javascript是单线程的，当send()方法阻塞时，它通常会导致整个浏览器UI冻结。如果连接的服务器响应慢，那么用户的浏览器将冻结 1234567891011121314151617181920212223&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;&lt;div id=result&gt;&lt;/div&gt;&lt;script&gt; btn.onclick=function(){ var xhr; if(window.XMLHttpRequst){ var xhr = window.XMLHttpRequst; }else { xhr = new ActiveXObject('Microsoft.XMLHTTP'); } //发送请求 xhr.open(&quot;GET&quot;,&quot;xx.xml&quot;,false); xhr.send(); //同步接受响应 if(xhr.readyState==4){ if(xhr.status == 200){ result.innerHTML += xhr.responseText; } } } &lt;/script&gt; 12//message.xml&lt;p&gt;hello world&lt;/p&gt; 异步 如果接受的异步响应，这就需要检测XHR的readyState的属性，该属性表示，请求/响应过程中当前的活动阶段，这个属性可以去一下的值， 123450(UNSENT):未初始化。尚未调用open()方法1(OPENED):启动。已经调用open()方法，但尚未调用send()方法2(HEADERS_RECEIVED):发送。己经调用send()方法，且接收到头信息3(LOADING):接收。已经接收到部分响应主体信息4(DONE):完成。已经接收到全部响应数据，而且已经可以在客户端使用了 理论上，只要readyState属性的值由一个值变为另一个值，就会出发一次readyStatechange事件，可以利用这个事件来检测每次状态变化的readyState的值，我们对readyState值为4的阶段感兴趣，因为这时所有数据都已就绪， 12345678910111213141516171819202122232425&lt;button id=&quot;btn&quot;&gt;获取信息&lt;/button&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt;btn.onclick = function(){ //创建xhr对象 var xhr; if(window.XMLHttpRequest){ xhr = new XMLHttpRequest(); }else{ xhr = new ActiveXObject('Microsoft.XMLHTTP'); } //异步接受响应 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status == 200){ //实际操作 result.innerHTML += xhr.responseText; } } } //发送请求 xhr.open('get','message.xml',true); xhr.send();}&lt;/script&gt; 超时 1234567xhr.open(&quot;GET&quot;,&quot;xxx.php&quot;,true);xhr.ontimeout=function(){ console.log(&quot;请求超市&quot;)}xhr.timeout = 1000;xhr.send(); 优化 使用AJAX接收数据时，由于网络和数据大小的原因，并不是立刻就可以在页面中显示出来。所以，更好的做法是，在接受数据的过程中，显示一个类似loading的小图片，并且禁用按钮；当数据完全接收后，再隐藏该图片，并启用按钮。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;button id=&quot;btn&quot;&gt;获取信息&lt;/button&gt;&lt;img id=&quot;img&quot; height=&quot;16&quot; style=&quot;display:none&quot; src=&quot;data:image/gif;base64,R0lGODlhIAAgALMAAP///7Ozs/v7+9bW1uHh4fLy8rq6uoGBgTQ0NAEBARsbG8TExJeXl/39/VRUVAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBQAAACwAAAAAIAAgAAAE5xDISSlLrOrNp0pKNRCdFhxVolJLEJQUoSgOpSYT4RowNSsvyW1icA16k8MMMRkCBjskBTFDAZyuAEkqCfxIQ2hgQRFvAQEEIjNxVDW6XNE4YagRjuBCwe60smQUDnd4Rz1ZAQZnFAGDd0hihh12CEE9kjAEVlycXIg7BAsMB6SlnJ87paqbSKiKoqusnbMdmDC2tXQlkUhziYtyWTxIfy6BE8WJt5YEvpJivxNaGmLHT0VnOgGYf0dZXS7APdpB309RnHOG5gDqXGLDaC457D1zZ/V/nmOM82XiHQjYKhKP1oZmADdEAAAh+QQFBQAAACwAAAAAGAAXAAAEchDISasKNeuJFKoHs4mUYlJIkmjIV54Soypsa0wmLSnqoTEtBw52mG0AjhYpBxioEqRNy8V0qFzNw+GGwlJki4lBqx1IBgjMkRIghwjrzcDti2/Gh7D9qN774wQGAYOEfwCChIV/gYmDho+QkZKTR3p7EQAh+QQFBQAAACwBAAAAHQAOAAAEchDISWdANesNHHJZwE2DUSEo5SjKKB2HOKGYFLD1CB/DnEoIlkti2PlyuKGEATMBaAACSyGbEDYD4zN1YIEmh0SCQQgYehNmTNNaKsQJXmBuuEYPi9ECAU/UFnNzeUp9VBQEBoFOLmFxWHNoQw6RWEocEQAh+QQFBQAAACwHAAAAGQARAAAEaRDICdZZNOvNDsvfBhBDdpwZgohBgE3nQaki0AYEjEqOGmqDlkEnAzBUjhrA0CoBYhLVSkm4SaAAWkahCFAWTU0A4RxzFWJnzXFWJJWb9pTihRu5dvghl+/7NQmBggo/fYKHCX8AiAmEEQAh+QQFBQAAACwOAAAAEgAYAAAEZXCwAaq9ODAMDOUAI17McYDhWA3mCYpb1RooXBktmsbt944BU6zCQCBQiwPB4jAihiCK86irTB20qvWp7Xq/FYV4TNWNz4oqWoEIgL0HX/eQSLi69boCikTkE2VVDAp5d1p0CW4RACH5BAUFAAAALA4AAAASAB4AAASAkBgCqr3YBIMXvkEIMsxXhcFFpiZqBaTXisBClibgAnd+ijYGq2I4HAamwXBgNHJ8BEbzgPNNjz7LwpnFDLvgLGJMdnw/5DRCrHaE3xbKm6FQwOt1xDnpwCvcJgcJMgEIeCYOCQlrF4YmBIoJVV2CCXZvCooHbwGRcAiKcmFUJhEAIfkEBQUAAAAsDwABABEAHwAABHsQyAkGoRivELInnOFlBjeM1BCiFBdcbMUtKQdTN0CUJru5NJQrYMh5VIFTTKJcOj2HqJQRhEqvqGuU+uw6AwgEwxkOO55lxIihoDjKY8pBoThPxmpAYi+hKzoeewkTdHkZghMIdCOIhIuHfBMOjxiNLR4KCW1ODAlxSxEAIfkEBQUAAAAsCAAOABgAEgAABGwQyEkrCDgbYvvMoOF5ILaNaIoGKroch9hacD3MFMHUBzMHiBtgwJMBFolDB4GoGGBCACKRcAAUWAmzOWJQExysQsJgWj0KqvKalTiYPhp1LBFTtp10Is6mT5gdVFx1bRN8FTsVCAqDOB9+KhEAIfkEBQUAAAAsAgASAB0ADgAABHgQyEmrBePS4bQdQZBdR5IcHmWEgUFQgWKaKbWwwSIhc4LonsXhBSCsQoOSScGQDJiWwOHQnAxWBIYJNXEoFCiEWDI9jCzESey7GwMM5doEwW4jJoypQQ743u1WcTV0CgFzbhJ5XClfHYd/EwZnHoYVDgiOfHKQNREAIfkEBQUAAAAsAAAPABkAEQAABGeQqUQruDjrW3vaYCZ5X2ie6EkcKaooTAsi7ytnTq046BBsNcTvItz4AotMwKZBIC6H6CVAJaCcT0CUBTgaTg5nTCu9GKiDEMPJg5YBBOpwlnVzLwtqyKnZagZWahoMB2M3GgsHSRsRACH5BAUFAAAALAEACAARABgAAARcMKR0gL34npkUyyCAcAmyhBijkGi2UW02VHFt33iu7yiDIDaD4/erEYGDlu/nuBAOJ9Dvc2EcDgFAYIuaXS3bbOh6MIC5IAP5Eh5fk2exC4tpgwZyiyFgvhEMBBEAIfkEBQUAAAAsAAACAA4AHQAABHMQyAnYoViSlFDGXBJ808Ep5KRwV8qEg+pRCOeoioKMwJK0Ekcu54h9AoghKgXIMZgAApQZcCCu2Ax2O6NUud2pmJcyHA4L0uDM/ljYDCnGfGakJQE5YH0wUBYBAUYfBIFkHwaBgxkDgX5lgXpHAXcpBIsRADs=&quot; alt=&quot;loading&quot;&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt;var add = (function(){ var counter = 0; return function(){ return ++counter; }})();btn.onclick = function(){ img.style.display = 'inline-block'; btn.setAttribute('disabled',''); //创建xhr对象 var xhr; if(window.XMLHttpRequest){ xhr = new XMLHttpRequest(); }else{ xhr = new ActiveXObject('Microsoft.XMLHTTP'); } //异步接受响应 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status == 200){ img.style.display = 'none'; btn.removeAttribute('disabled'); var data = JSON.parse(xhr.responseText); var sum = add() - 1; if(sum &lt; data.length){ result.innerHTML += data[sum]; } } } } //发送请求 xhr.open('get','data.php',true); xhr.send();}&lt;/script&gt; 123&lt;?phpecho json_encode([1,2,3,4,5]);?&gt;","link":"/blog/2021"},{"title":"关于VUE项目基本结构","text":"前言：框架vue2.x，构建工具webpack4.x, node.js 8.11x, 系统window，ES6, Axios1：vue项目目录文件结构 备注：在初始化项目后src目录下components只用来存放项目公共组件，不用来存放页面其他组件 2：基于初始化得项目结构，添加开发所需要得必要文件，所有业务代码统一放在src目录下，对于项目层级的划分可以： 抽离所有的api接口统一管理，每个模块的api也单独管理 所有单页早src下新建views管理所有页面 项目使用的所有公共方法，以及相关的工具，统一在src下新建utils文件夹管理 项目所需要用到的字体统一在src下新建fonts管理 项目所需要的主题统一在src下新建theme管理 公共css文件在src下新建style管理 3：编码命名 1.驼峰命名法(camelCase): 又称为小驼峰命名法，除第一个单词的首字母小写，其他单词的首字母均大写。 2. 帕斯卡命名法(PascalCase): 又称为大驼峰命名法，所有单词的首字母均大写。常用于类名、命名空间 3. 下划线命名法(Underline): 多个单词之间以下划线连接，大写常用于常量，小写常用于文件命名。 4. 短横线命名法(kebab-case): 多个单词之间以短横线(-)连接，单词全部小写。 5. 匈牙利命名法(Hungarian): 通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识除变量的作用域、类型等。广泛应用于Windows编程中。 1：命名 1：变量使用Camel(驼峰)命名法，例如 var loadingModules = {} 2：函数使用Camel命名法，例如 function stringFormat() {} 3：常量使用全部字母大写，单词间下划线分割，例如 var HTML_ENTRY = {} 4：建议boolean类型的变量使用 is 或者 has 开头，例如 var isTrue = false; var hasMoreInfo = true 5：项目文件夹的命名一般用小写，例如 notice 6：在html中 对于class的命名统一使用短横线命名法，例如 &lt;div class=&quot;head-wrapper&quot;&gt;&lt;/div&gt; 7：在组件中，对于组件name的命名(子组件)，统一采取短横线命名法，例如 export default { name: 'fatherName-childrenName' } 4：代码规范 1：代码规范（css）（基于scss） 备注：关于缩进问题，无论是编辑器还是eslint规范（编辑器的格式化会基本达到标准的规范），还是个人习惯，都没有太大影响，保持自己的习惯就行，这里只是大致做一些基本的规范 1：对于超长的样式，在样式值得空格或者逗号后换行，建议按照逻辑分组，例如 // 不同属性值按照逻辑分组 background: transparent url(xxxx) no-repeat 0 0; 2：scss得嵌套层级3层为宜，例如 .wrapper { width: 120px; .header-wrapper { height: 120px; .title { font-size: 16px; } } } 3：当一个rule包含多个selector时，每个声明得选择器必须独占一行，例如 .container, .wrapper, .comment { font-size: 12px } 4：属性选择器中值必须时双引号包围，例如 article[character=&quot;wanggang&quot;] { font-size: 12px; } 5：属性值必须领起一行，例如 .wrapper { margin: 0; padding: 0 } 6：属性值必须以分号结尾，例如 .wrapper { font-size: 10px; } 7：建议对于z-index进行分层，对于文档流外的绝对定位的视觉层进行管理。 8：当css的属性中 url函数中路劲不加引号，例如 body { // good background: url(path) // bad background: url(&quot;path&quot;) } 9：关于scss混合，定义全局公用的css方法，通过@include调用，避免重复写css代码片段，例如 //全局css方法 @mixin radius ($radius:5px) { border-radius: $radius; height: 12px; width: 120px; } //组件引用 .wrapper { @include: radius(10px); } 2：javascript(vue)基本规范 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt;export default { // 组件名称 name: 'name', // 引入组件 components: { xxx }, // 接受数据 props: { xxx }, // 过滤器 filter: { xxx: { xxx } }, // 混入 mixins: [ xxx ], // 组件实例数据 data() { return { xxx } }, // 计算属性 computed: { xxx }, // 监听属性变化 执行异步或者是开销比较大的操作 watch: { xxx }, // 渲染函数 jsx render(h) =&gt; { xxx }, mounted() { //页面初始化方法 }, methods: { //实例方法集合 }}&lt;/script&gt; 以上并没有列出所有的生命周期，只是针对于现有项目大多数情况下通用的一种情况，原则上，将生命周期函数尽量放下面，而将，mixin，data, computed, fliter，components, props等尽量放在上面，以便能够快速读懂组件。 2：关于组件划分原则( 原则上每个组件只做一件事情，组件(模块)不仅仅是为了复用，个人理解有以下几方面：) 组件化是对实现的分层，是更加有效， 组件化是对资源的重组和优化。使得项目资源趋于合理 组件划有利于单元测试 组件划对于重构也是非常的友好 组件的的设计原则一般有以下情况，可根据实际的业务做以调整（不死板），大的方向基本不变化 单一职责原则 追求短小精悍 避免太多参数（重要） 避免暴露组件内部实现（重要） 避免直接操作DOM 入口检查参数的有效性，出口检查返回的正确性（重要**重要） 3：公共方法的封装 前面有说到公共方法可以在utils中新建文件夹统一管理，然后再调用的地方调用，还将方法挂载到Vue的实例上，在组件中调用，例如: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 示例代码 ① 在utils中统一管理实例代码/** * 让时间戳按照指定的日期格式显示的方法 * @author wanggang * @param { String } 格式字符串 * @return { String } 返回生成的日期时间字符串 * @example * let d = +new Date(); * let pattern = &quot;YYYY-MM-DD&quot;; * return formatDate(d, pattern); */ export function formatDate(timestamp,pattern) { /* * eg:pattern=&quot;YYYY-MM-DD hh:mm:ss&quot;; * */ var d = new Date(timestamp); var o = { &quot;W+&quot; : d.getDay() == 0 ? 7 : d.getDay(), //week &quot;M+&quot; : d.getMonth() + 1, //month &quot;D+&quot; : d.getDate(), //day &quot;d+&quot; : d.getDate(), //day &quot;h+&quot; : d.getHours(), //hour &quot;m+&quot; : d.getMinutes(), //minute &quot;s+&quot; : d.getSeconds(), //second &quot;q+&quot; : Math.floor((d.getMonth() + 3) / 3), //quarter &quot;S&quot; : d.getMilliseconds(), //millisecond &quot;f+&quot; : d.getMilliseconds() } if (/(Y+)/.test(pattern) || /(y+)/.test(pattern)) { pattern = pattern.replace(RegExp.$1, (d.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); } for (var k in o) { if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(pattern)) { pattern = pattern.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)); } } return pattern;}备注:对于相对复杂的公共方法，原则上建议 使用标准的多行注释代码块，包括基本的方法名：@parmas(参数，类型)，@return (返回值，类型)，@example（使用案例）,至于创建时间，更新时间，邮箱，作者等可忽略// 示例代码 ② 在utils中统一管理实例代码/** * 生成随机数的方法 * @param { Number } min 生成随机数的最小值 * @param { Number } max 生成随机数的最大值 * @return { Number } 返回生成的随机数 */export function getRandom() { return Math.floor(Math.random() * (max - min + 1) + min);}备注： 对于一般性的方法，应具备 @params 和 @return，并且和值对应的类型// 示例代码 ③ 在utils中统一管理实例代码/*** 返回字节数 ***/export function byteLength(value) { return value.replace(/[^\\x00-\\xff]/g, &quot;**&quot;).length;}备注： 对于相对简单的方法 可以做一行注释（多上注释的规则）// 示例代码 ① 挂载在vue原型上Vue.prototype.getWindowHeight = function() { return window.innerHeight || document.documentElement.height || document.body.clientHeight}组件中以 this.getWindowHeight()调用。不过建议以统一在utils中统一管理，需要使用的时候引入相关的方法。尽量避免过多使用this，和过多在prototype上挂载方法属性等。 4：关于请求（Axios）（http.js） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186// 请求库import axios from 'axios';import { Message } from 'element-ui';// 设定超时axios.default.timeout = 10000;// post请求头axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';// 请求拦截器 对requestaxios.interceptors.request.use(config =&gt; { // 发起请求之前判断 仅仅为示例代码 // 假设token存在localStorage中 // 如果token存在，在每次得请求header上带上token // token存在，但是token已经过期，在响应拦截器中对返回得状态进行判断 const token = window.localStorage.token; token &amp;&amp; (config.headers.Authorization = token) return config}, err =&gt; { return Promise.reject(err);});// 请求拦截器 对responseaxios.interceptors.response.use(response =&gt; { if(response.status === 200){ return Promise.resolve(response); } else { return Promise.reject(response); }}, err =&gt; { if(err.response){ let status = err.response.status; switch(status) { // 401未登陆 // 未登陆 则条状到登陆页面，并且携带当前页面得path // 登陆成功后 返回当前页面 case 401: router.replace({ path: '/login', query: { redirect: router.currentRouter.fullPath } }); break; // 403 token过期 // 登陆过期 对用户进行提示 // 登陆成功返回当前页面 // 跳转登陆页 case 403: Message({ message : '登陆过期，请重新登陆'， duration: 2000 }) break; case 404: Message({ message: '网络请求不存在', duration: 2000 }) break; // 其他错误统一抛出，如果要对其中得返回码进行其他操作，在视情况在加case 进行操作 default: Message({ message : error.response.message, durantion : 2000 }) } } return Promise.reject(err);})// 请求封装/** * GET 封装 * @param url * @param data * @return { Promise } * */export function get(url, params = {}) { return new Promise((resolve, reject) =&gt; { axios.get(url, { params: params }) .then((res) =&gt; { resolve(res.data) }) .catch((err) =&gt; { reject(err) }) })}/*** POST 封装* @param url* @param data* @return { Promise }* */export function post(url, params = {}) { return new Promise((resolve, reject) =&gt; { axios.post(url, params) .then((res) =&gt; { resolve(res.data) }) .catch((err) =&gt; { reject(err) }) })}/*** PATCH 封装* @param url* @param data* @returns { Promise }* */export function patch(url, params = {}) { return new Promise((resolve, reject) =&gt; { axios.patch(url, params) .then((res) =&gt; { resolve(res.data) }) .catch((err) =&gt; { reject(err) }) })}/*** put 封装* @param url* @param data* @returns { Promise }* */export function put(url, params = {}) { return new Promise((resolve, reject) =&gt; { axios.put(url, params) .then((res) =&gt; { resolve(res.data) }) .catch((err) =&gt; { reject(err) }) })}/*** deltet 封装* @param url* @param data* @returns { Promise }* */export function deleteItem(url, params = {}) { return new Promise((resolve, reject) =&gt; { axios.delete(url, params) .then((res) =&gt; { resolve(res.data) }) .catch((err) =&gt; { reject(err) }) })} 接口管理（示例） 在src目录下新建文件夹api 12345678910111213141516171819202122232425262728293031// 文件夹src -api -setting -xxx -xxx// 在api下对每个模块新建文件夹统一管理// 以setting模块为例,如下：/** * setting 模块接口 */// 引入对应的方法import { get, post, put, deleteItem, patch } from '../../utils/http'/** * 接口配置列表 interfaceList */export const interfaceList = (params) =&gt; get('/setting/api', params)/** * 获取属性列表 getAttributes */export const getAttributes = (params) =&gt; get('/pdm/attribute', params)...... 在组件中调用如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;script&gt;// 代码仅作为例子import { getAttributes } from 'api/setting/index.js'export default { data() { return { dataAttr : [], arr : ['category_attributes','attribute_values'], defaultPropsAttr : { children : &quot;children&quot;, label : &quot;value&quot; }, } }, mounted() { let params = { id : 1, value: '小蓝瓶' } getAttributes(params).then( res =&gt; { if(res.success){ this.dataAttr = res.data.map(this.deepMap) } }).then(() =&gt; {}).then(() =&gt; {}) }, methods: { deepMap(v, index) { let keys = this.arr.find(key =&gt; v[key]); let val = v[keys] if(!val) return { ...v, value:v.valus } return { ...v, value: v.name children: val.map(this.deepMap) } } }}&lt;/script&gt;备注：1：以上代码仅仅为示例代码 2：在模块中引入对应的方法，方法接受参数（对象），将对象传入，then回调中获取结果， 3：如果再then回调中有比较多的业务代码，原则上，写在独立的方法中，如上述案例， 4：如果有多层then回调，原则上应该将then中的逻辑都写在独立的方法中","link":"/blog/2021"}],"tags":[],"categories":[]}